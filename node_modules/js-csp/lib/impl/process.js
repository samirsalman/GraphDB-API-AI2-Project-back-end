'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Process = exports.NO_VALUE = undefined;

var _setImmediate2 = require('babel-runtime/core-js/set-immediate');

var _setImmediate3 = _interopRequireDefault(_setImmediate2);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

exports.putThenCallback = putThenCallback;
exports.takeThenCallback = takeThenCallback;
exports.take = take;
exports.put = put;
exports.sleep = sleep;
exports.alts = alts;
exports.poll = poll;
exports.offer = offer;

var _select = require('./select');

var _handlers = require('./handlers');

var _instruction = require('./instruction');

var _boxes = require('./boxes');

var _channels = require('./channels');

var _dispatch = require('./dispatch');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var NO_VALUE = exports.NO_VALUE = '@@process/NO_VALUE';

function putThenCallback(channel, value, callback) {
  var result = channel.put(value, new _handlers.FnHandler(true, callback));

  if (result && callback) {
    callback(result.value);
  }
}

function takeThenCallback(channel, callback) {
  var result = channel.take(new _handlers.FnHandler(true, callback));

  if (result && callback) {
    callback(result.value);
  }
}

function take(channel) {
  return new _instruction.TakeInstruction(channel);
}

function put(channel, value) {
  return new _instruction.PutInstruction(channel, value);
}

function sleep(msecs) {
  return new _instruction.SleepInstruction(msecs);
}

function alts(operations, options) {
  return new _instruction.AltsInstruction(operations, options);
}

function poll(channel) {
  if (channel.closed) {
    return NO_VALUE;
  }

  var result = channel.take(new _handlers.FnHandler(false));

  return result ? result.value : NO_VALUE;
}

function offer(channel, value) {
  if (channel.closed) {
    return false;
  }

  var result = channel.put(value, new _handlers.FnHandler(false));

  return result instanceof _boxes.Box;
}

var Process = exports.Process = function () {
  function Process(gen, onFinishFunc, creatorFunc) {
    var _this = this;

    (0, _classCallCheck3.default)(this, Process);

    this.schedule = function (nextState) {
      (0, _setImmediate3.default)(function () {
        return _this.run(nextState);
      });
    };

    this.gen = gen;
    this.finished = false;
    this.creatorFunc = creatorFunc;
    this.onFinishFunc = onFinishFunc;
  }

  (0, _createClass3.default)(Process, [{
    key: 'run',
    value: function run(state) {
      if (!this.finished) {
        // TODO: Shouldn't we (optionally) stop error propagation here (and
        // signal the error through a channel or something)? Otherwise the
        // uncaught exception will crash some runtimes (e.g. Node)
        var _gen$next = this.gen.next(state),
            done = _gen$next.done,
            value = _gen$next.value;

        if (done) {
          this.finished = true;
          this.onFinishFunc(value);
        } else if (value instanceof _instruction.TakeInstruction) {
          takeThenCallback(value.channel, this.schedule);
        } else if (value instanceof _instruction.PutInstruction) {
          putThenCallback(value.channel, value.value, this.schedule);
        } else if (value instanceof _instruction.SleepInstruction) {
          (0, _dispatch.queueDelay)(this.schedule, value.msec);
        } else if (value instanceof _instruction.AltsInstruction) {
          (0, _select.doAlts)(value.operations, this.schedule, value.options);
        } else if (value instanceof _channels.Channel) {
          takeThenCallback(value, this.schedule);
        } else {
          this.schedule(value);
        }
      }
    }
  }]);
  return Process;
}();