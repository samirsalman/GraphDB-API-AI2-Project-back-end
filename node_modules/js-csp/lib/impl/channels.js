'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Channel = exports.CLOSED = exports.MAX_QUEUE_SIZE = exports.MAX_DIRTY = undefined;

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

exports.chan = chan;

var _buffers = require('./buffers');

var _boxes = require('./boxes');

var _utils = require('./utils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var MAX_DIRTY = exports.MAX_DIRTY = 64;
var MAX_QUEUE_SIZE = exports.MAX_QUEUE_SIZE = 1024;
var CLOSED = exports.CLOSED = null;

var Channel = exports.Channel = function () {
  function Channel(takes, puts, buf, xform) {
    (0, _classCallCheck3.default)(this, Channel);

    this.buf = buf;
    this.xform = xform;
    this.takes = takes;
    this.puts = puts;
    this.dirtyTakes = 0;
    this.dirtyPuts = 0;
    this.closed = false;
  }

  (0, _createClass3.default)(Channel, [{
    key: 'put',
    value: function put(value, handler) {
      if (value === CLOSED) {
        throw new Error('Cannot put CLOSED on a channel.');
      }

      // TODO: I'm not sure how this can happen, because the operations
      // are registered in 1 tick, and the only way for this to be inactive
      // is for a previous operation in the same alt to have returned
      // immediately, which would have short-circuited to prevent this to
      // be ever register anyway. The same thing goes for the active check
      // in "take".
      if (!handler.isActive()) {
        return null;
      }

      if (this.closed) {
        handler.commit();
        return new _boxes.Box(false);
      }

      // Soak the value through the buffer first, even if there is a
      // pending taker. This way the step function has a chance to act on the
      // value.
      if (this.buf && !this.buf.isFull()) {
        handler.commit();
        var done = (0, _utils.isReduced)(this.xform['@@transducer/step'](this.buf, value));

        // flow-ignore
        while (this.buf.count() > 0 && this.takes.length > 0) {
          var taker = this.takes.pop();

          // flow-ignore
          if (taker.isActive()) {
            // flow-ignore
            (0, _utils.taskScheduler)(taker.commit(), this.buf.remove());
          }
        }

        if (done) {
          this.close();
        }
        return new _boxes.Box(true);
      }

      // Either the buffer is full, in which case there won't be any
      // pending takes, or we don't have a buffer, in which case this loop
      // fulfills the first of them that is active (note that we don't
      // have to worry about transducers here since we require a buffer
      // for that).
      while (this.takes.length > 0) {
        var _taker = this.takes.pop();

        // flow-ignore
        if (_taker.isActive()) {
          handler.commit();
          // flow-ignore
          (0, _utils.taskScheduler)(_taker.commit(), value);
          return new _boxes.Box(true);
        }
      }

      // No buffer, full buffer, no pending takes. Queue this put now if blockable.
      if (this.dirtyPuts > MAX_DIRTY) {
        this.puts.cleanup(function (putter) {
          return putter.handler.isActive();
        });
        this.dirtyPuts = 0;
      } else {
        this.dirtyPuts += 1;
      }

      if (handler.isBlockable()) {
        if (this.puts.length >= MAX_QUEUE_SIZE) {
          throw new Error('No more than ' + MAX_QUEUE_SIZE + ' pending puts are allowed on a single channel.');
        }
        this.puts.unboundedUnshift(new _boxes.PutBox(handler, value));
      }

      return null;
    }
  }, {
    key: 'take',
    value: function take(handler) {
      if (!handler.isActive()) {
        return null;
      }

      if (this.buf && this.buf.count() > 0) {
        handler.commit();
        // flow-ignore
        var value = this.buf.remove();

        // We need to check pending puts here, other wise they won't
        // be able to proceed until their number reaches MAX_DIRTY

        // flow-ignore
        while (this.puts.length > 0 && !this.buf.isFull()) {
          var putter = this.puts.pop();

          // flow-ignore
          if (putter.handler.isActive()) {
            // flow-ignore
            (0, _utils.taskScheduler)(putter.handler.commit(), true);

            // flow-ignore
            if ((0, _utils.isReduced)(this.xform['@@transducer/step'](this.buf, putter.value))) {
              this.close();
            }
          }
        }
        return new _boxes.Box(value);
      }

      // Either the buffer is empty, in which case there won't be any
      // pending puts, or we don't have a buffer, in which case this loop
      // fulfills the first of them that is active (note that we don't
      // have to worry about transducers here since we require a buffer
      // for that).
      while (this.puts.length > 0) {
        var _putter = this.puts.pop();

        // flow-ignore
        if (_putter.handler.isActive()) {
          handler.commit();
          // flow-ignore
          (0, _utils.taskScheduler)(_putter.handler.commit(), true);

          // flow-ignore
          return new _boxes.Box(_putter.value);
        }
      }

      if (this.closed) {
        handler.commit();
        return new _boxes.Box(CLOSED);
      }

      // No buffer, empty buffer, no pending puts. Queue this take now if blockable.
      if (this.dirtyTakes > MAX_DIRTY) {
        this.takes.cleanup(function (_handler) {
          return _handler.isActive();
        });
        this.dirtyTakes = 0;
      } else {
        this.dirtyTakes += 1;
      }

      if (handler.isBlockable()) {
        if (this.takes.length >= MAX_QUEUE_SIZE) {
          throw new Error('No more than ' + MAX_QUEUE_SIZE + ' pending takes are allowed on a single channel.');
        }

        this.takes.unboundedUnshift(handler);
      }

      return null;
    }
  }, {
    key: 'close',
    value: function close() {
      if (this.closed) {
        return;
      }

      this.closed = true;

      if (this.buf) {
        this.xform['@@transducer/result'](this.buf);

        // flow-ignore
        while (this.buf.count() > 0 && this.takes.length > 0) {
          var taker = this.takes.pop();

          // flow-ignore
          if (taker.isActive()) {
            // flow-ignore
            (0, _utils.taskScheduler)(taker.commit(), this.buf.remove());
          }
        }
      }

      (0, _utils.flush)(this.takes, function (taker) {
        if (taker.isActive()) {
          (0, _utils.taskScheduler)(taker.commit(), CLOSED);
        }
      });

      (0, _utils.flush)(this.puts, function (putter) {
        if (putter.handler.isActive()) {
          (0, _utils.taskScheduler)(putter.handler.commit(), false);
        }
      });
    }
  }, {
    key: 'isClosed',
    value: function isClosed() {
      return this.closed;
    }
  }]);
  return Channel;
}();

// The base transformer object to use with transducers


var AddTransformer = {
  '@@transducer/init': function transducerInit() {
    throw new Error('init not available');
  },

  '@@transducer/result': function transducerResult(v) {
    return v;
  },

  '@@transducer/step': function transducerStep(buffer, input) {
    buffer.add(input);
    return buffer;
  }
};

function defaultExceptionHandler(err) {
  console.log('error in channel transformer', err.stack); // eslint-disable-line
  return CLOSED;
}

function handleEx(buf, exHandler, e) {
  var def = (exHandler || defaultExceptionHandler)(e);

  if (def !== CLOSED) {
    buf.add(def);
  }

  return buf;
}

function handleException(exHandler) {
  return function (xform) {
    return {
      '@@transducer/step': function transducerStep(buffer, input) {
        try {
          return xform['@@transducer/step'](buffer, input);
        } catch (e) {
          return handleEx(buffer, exHandler, e);
        }
      },
      '@@transducer/result': function transducerResult(buffer) {
        try {
          return xform['@@transducer/result'](buffer);
        } catch (e) {
          return handleEx(buffer, exHandler, e);
        }
      }
    };
  };
}

// XXX: This is inconsistent. We should either call the reducing
// function xform, or call the transducers xform, not both
function chan(buf, xform, exHandler) {
  var newXForm = void 0;

  if (xform) {
    if (!buf) {
      throw new Error('Only buffered channels can use transducers');
    }

    newXForm = xform(AddTransformer);
  } else {
    newXForm = AddTransformer;
  }

  return new Channel((0, _buffers.ring)(32), (0, _buffers.ring)(32), buf, handleException(exHandler)(newXForm));
}