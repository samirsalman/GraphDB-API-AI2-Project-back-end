"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PromiseBuffer = exports.SlidingBuffer = exports.DroppingBuffer = exports.FixedBuffer = exports.RingBuffer = undefined;

var _classCallCheck2 = require("babel-runtime/helpers/classCallCheck");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require("babel-runtime/helpers/createClass");

var _createClass3 = _interopRequireDefault(_createClass2);

exports.ring = ring;
exports.fixed = fixed;
exports.dropping = dropping;
exports.sliding = sliding;
exports.promise = promise;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function acopy(src, srcStart, dest, destStart, len) {
  for (var count = 0; count < len; count += 1) {
    dest[destStart + count] = src[srcStart + count];
  }
}

var RingBuffer = exports.RingBuffer = function () {
  function RingBuffer(head, tail, length, arr) {
    (0, _classCallCheck3.default)(this, RingBuffer);

    this.head = head;
    this.tail = tail;
    this.length = length;
    this.arr = arr;
  }

  (0, _createClass3.default)(RingBuffer, [{
    key: "pop",
    value: function pop() {
      if (this.length !== 0) {
        var elem = this.arr[this.tail];

        this.arr[this.tail] = undefined;
        this.tail = (this.tail + 1) % this.arr.length;
        this.length -= 1;

        return elem;
      }

      return undefined;
    }
  }, {
    key: "unshift",
    value: function unshift(element) {
      this.arr[this.head] = element;
      this.head = (this.head + 1) % this.arr.length;
      this.length += 1;
    }
  }, {
    key: "unboundedUnshift",
    value: function unboundedUnshift(element) {
      if (this.length + 1 === this.arr.length) {
        this.resize();
      }
      this.unshift(element);
    }
  }, {
    key: "resize",
    value: function resize() {
      var newArrSize = this.arr.length * 2;
      var newArr = new Array(newArrSize);

      if (this.tail < this.head) {
        acopy(this.arr, this.tail, newArr, 0, this.length);
        this.tail = 0;
        this.head = this.length;
        this.arr = newArr;
      } else if (this.tail > this.head) {
        acopy(this.arr, this.tail, newArr, 0, this.arr.length - this.tail);
        acopy(this.arr, 0, newArr, this.arr.length - this.tail, this.head);
        this.tail = 0;
        this.head = this.length;
        this.arr = newArr;
      } else if (this.tail === this.head) {
        this.tail = 0;
        this.head = 0;
        this.arr = newArr;
      }
    }
  }, {
    key: "cleanup",
    value: function cleanup(predicate) {
      for (var i = this.length; i > 0; i -= 1) {
        var value = this.pop();

        if (predicate(value)) {
          this.unshift(value);
        }
      }
    }
  }]);
  return RingBuffer;
}();

function ring(n) {
  if (n <= 0) {
    throw new Error("Can't create a ring buffer of size 0");
  }

  return new RingBuffer(0, 0, 0, new Array(n));
}

/**
 * Returns a buffer that is considered "full" when it reaches size n,
 * but still accepts additional items, effectively allow overflowing.
 * The overflowing behavior is useful for supporting "expanding"
 * transducers, where we want to check if a buffer is full before
 * running the transduced step function, while still allowing a
 * transduced step to expand into multiple "essence" steps.
 */

var FixedBuffer = exports.FixedBuffer = function () {
  function FixedBuffer(buffer, n) {
    (0, _classCallCheck3.default)(this, FixedBuffer);

    this.buffer = buffer;
    this.n = n;
  }

  (0, _createClass3.default)(FixedBuffer, [{
    key: "isFull",
    value: function isFull() {
      return this.buffer.length === this.n;
    }
  }, {
    key: "remove",
    value: function remove() {
      return this.buffer.pop();
    }
  }, {
    key: "add",
    value: function add(item) {
      this.buffer.unboundedUnshift(item);
    }
  }, {
    key: "closeBuffer",
    value: function closeBuffer() {} // eslint-disable-line

  }, {
    key: "count",
    value: function count() {
      return this.buffer.length;
    }
  }]);
  return FixedBuffer;
}();

function fixed(n) {
  return new FixedBuffer(ring(n), n);
}

var DroppingBuffer = exports.DroppingBuffer = function () {
  function DroppingBuffer(buffer, n) {
    (0, _classCallCheck3.default)(this, DroppingBuffer);

    this.buffer = buffer;
    this.n = n;
  }

  (0, _createClass3.default)(DroppingBuffer, [{
    key: "isFull",
    value: function isFull() {
      // eslint-disable-line
      return false;
    }
  }, {
    key: "remove",
    value: function remove() {
      return this.buffer.pop();
    }
  }, {
    key: "add",
    value: function add(item) {
      if (this.buffer.length !== this.n) {
        this.buffer.unshift(item);
      }
    }
  }, {
    key: "closeBuffer",
    value: function closeBuffer() {} // eslint-disable-line

  }, {
    key: "count",
    value: function count() {
      return this.buffer.length;
    }
  }]);
  return DroppingBuffer;
}();

function dropping(n) {
  return new DroppingBuffer(ring(n), n);
}

var SlidingBuffer = exports.SlidingBuffer = function () {
  function SlidingBuffer(buffer, n) {
    (0, _classCallCheck3.default)(this, SlidingBuffer);

    this.buffer = buffer;
    this.n = n;
  }

  (0, _createClass3.default)(SlidingBuffer, [{
    key: "isFull",
    value: function isFull() {
      // eslint-disable-line
      return false;
    }
  }, {
    key: "remove",
    value: function remove() {
      return this.buffer.pop();
    }
  }, {
    key: "add",
    value: function add(item) {
      if (this.buffer.length === this.n) {
        this.remove();
      }

      this.buffer.unshift(item);
    }
  }, {
    key: "closeBuffer",
    value: function closeBuffer() {} // eslint-disable-line

  }, {
    key: "count",
    value: function count() {
      return this.buffer.length;
    }
  }]);
  return SlidingBuffer;
}();

function sliding(n) {
  return new SlidingBuffer(ring(n), n);
}

var PromiseBuffer = exports.PromiseBuffer = function () {
  function PromiseBuffer(value) {
    (0, _classCallCheck3.default)(this, PromiseBuffer);

    this.value = value;
  }

  (0, _createClass3.default)(PromiseBuffer, [{
    key: "isFull",
    value: function isFull() {
      // eslint-disable-line
      return false;
    }
  }, {
    key: "remove",
    value: function remove() {
      return this.value;
    }
  }, {
    key: "add",
    value: function add(item) {
      if (PromiseBuffer.isUndelivered(this.value)) {
        this.value = item;
      }
    }
  }, {
    key: "closeBuffer",
    value: function closeBuffer() {
      if (PromiseBuffer.isUndelivered(this.value)) {
        this.value = null;
      }
    }
  }, {
    key: "count",
    value: function count() {
      return PromiseBuffer.isUndelivered(this.value) ? 0 : 1;
    }
  }]);
  return PromiseBuffer;
}();

PromiseBuffer.NO_VALUE = '@@PromiseBuffer/NO_VALUE';

PromiseBuffer.isUndelivered = function (value) {
  return PromiseBuffer.NO_VALUE === value;
};

function promise() {
  return new PromiseBuffer(PromiseBuffer.NO_VALUE);
}