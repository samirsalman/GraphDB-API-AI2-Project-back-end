'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _setImmediate2 = require('babel-runtime/core-js/set-immediate');

var _setImmediate3 = _interopRequireDefault(_setImmediate2);

exports.queueDispatcher = queueDispatcher;
exports.run = run;
exports.queueDelay = queueDelay;

var _buffers = require('./buffers');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var TASK_BATCH_SIZE = 1024;

var tasks = (0, _buffers.ring)(32);
var running = false;
var queued = false;

function queueDispatcher() {
  // See the implementation of setImmediate at babel-runtime/core-js/set-immediate
  // https://github.com/zloirock/core-js/blob/e482646353b489e200a5ecccca6af5c01f0b4ef2/library/modules/_task.js
  // Under the hood, it will use process.nextTick, MessageChannel, and fallback to setTimeout
  if (!(queued && running)) {
    queued = true;

    (0, _setImmediate3.default)(function () {
      var count = 0;

      running = true;
      queued = false;

      while (count < TASK_BATCH_SIZE) {
        var task = tasks.pop();

        if (task) {
          task();
          count += 1;
        } else {
          break;
        }
      }

      running = false;

      if (tasks.length > 0) {
        queueDispatcher();
      }
    });
  }
}

function run(func) {
  tasks.unboundedUnshift(func);
  queueDispatcher();
}

function queueDelay(func, delay) {
  setTimeout(func, delay);
}