'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _toConsumableArray2 = require('babel-runtime/helpers/toConsumableArray');

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

exports.mapFrom = mapFrom;
exports.mapInto = mapInto;
exports.filterFrom = filterFrom;
exports.filterInto = filterInto;
exports.removeFrom = removeFrom;
exports.removeInto = removeInto;
exports.mapcatFrom = mapcatFrom;
exports.mapcatInto = mapcatInto;
exports.pipe = pipe;
exports.split = split;
exports.reduce = reduce;
exports.onto = onto;
exports.fromColl = fromColl;
exports.map = map;
exports.merge = merge;
exports.into = into;
exports.take = take;
exports.unique = unique;
exports.partitionBy = partitionBy;
exports.partition = partition;
exports.mult = mult;
exports.mix = mix;
exports.pub = pub;
exports.pipeline = pipeline;
exports.pipelineAsync = pipelineAsync;

var _times = require('lodash/times');

var _times2 = _interopRequireDefault(_times);

var _boxes = require('./impl/boxes');

var _channels = require('./impl/channels');

var _process = require('./impl/process');

var _csp = require('./csp.core');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _marked = [mapcat].map(_regenerator2.default.mark);

function mapFrom(f, ch) {
  return {
    isClosed: function isClosed() {
      return ch.isClosed();
    },
    close: function close() {
      ch.close();
    },
    put: function put(value, handler) {
      return ch.put(value, handler);
    },
    take: function take(handler) {
      var result = ch.take({
        isActive: function isActive() {
          return handler.isActive();
        },
        commit: function commit() {
          var takeCallback = handler.commit();
          return function (value) {
            return takeCallback(value === _channels.CLOSED ? _channels.CLOSED : f(value));
          };
        }
      });

      if (result) {
        var value = result.value;
        return new _boxes.Box(value === _channels.CLOSED ? _channels.CLOSED : f(value));
      }

      return null;
    }
  };
}

function mapInto(f, ch) {
  return {
    isClosed: function isClosed() {
      return ch.isClosed();
    },
    close: function close() {
      ch.close();
    },
    put: function put(value, handler) {
      return ch.put(f(value), handler);
    },
    take: function take(handler) {
      return ch.take(handler);
    }
  };
}

function filterFrom(p, ch, bufferOrN) {
  var out = (0, _csp.chan)(bufferOrN);

  (0, _csp.go)(_regenerator2.default.mark(function _callee() {
    var value;
    return _regenerator2.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return (0, _process.take)(ch);

          case 2:
            value = _context.sent;

            if (!(value === _channels.CLOSED)) {
              _context.next = 6;
              break;
            }

            out.close();
            return _context.abrupt('break', 11);

          case 6:
            if (!p(value)) {
              _context.next = 9;
              break;
            }

            _context.next = 9;
            return (0, _process.put)(out, value);

          case 9:
            _context.next = 0;
            break;

          case 11:
          case 'end':
            return _context.stop();
        }
      }
    }, _callee, this);
  }));
  return out;
}

function filterInto(p, ch) {
  return {
    isClosed: function isClosed() {
      return ch.isClosed();
    },
    close: function close() {
      ch.close();
    },
    put: function put(value, handler) {
      if (p(value)) {
        return ch.put(value, handler);
      }

      return new _boxes.Box(!ch.isClosed());
    },
    take: function take(handler) {
      return ch.take(handler);
    }
  };
}

function removeFrom(p, ch) {
  return filterFrom(function (value) {
    return !p(value);
  }, ch);
}

function removeInto(p, ch) {
  return filterInto(function (value) {
    return !p(value);
  }, ch);
}

function mapcat(f, src, dst) {
  var value, seq, length, i;
  return _regenerator2.default.wrap(function mapcat$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          _context2.next = 2;
          return (0, _process.take)(src);

        case 2:
          value = _context2.sent;

          if (!(value === _channels.CLOSED)) {
            _context2.next = 8;
            break;
          }

          dst.close();
          return _context2.abrupt('break', 21);

        case 8:
          seq = f(value);
          length = seq.length;
          i = 0;

        case 11:
          if (!(i < length)) {
            _context2.next = 17;
            break;
          }

          _context2.next = 14;
          return (0, _process.put)(dst, seq[i]);

        case 14:
          i += 1;
          _context2.next = 11;
          break;

        case 17:
          if (!dst.isClosed()) {
            _context2.next = 19;
            break;
          }

          return _context2.abrupt('break', 21);

        case 19:
          _context2.next = 0;
          break;

        case 21:
        case 'end':
          return _context2.stop();
      }
    }
  }, _marked[0], this);
}

function mapcatFrom(f, ch, bufferOrN) {
  var out = (0, _csp.chan)(bufferOrN);
  (0, _csp.go)(mapcat, [f, ch, out]);
  return out;
}

function mapcatInto(f, ch, bufferOrN) {
  var src = (0, _csp.chan)(bufferOrN);
  (0, _csp.go)(mapcat, [f, src, ch]);
  return src;
}

function pipe(src, dst, keepOpen) {
  (0, _csp.go)(_regenerator2.default.mark(function _callee2() {
    var value;
    return _regenerator2.default.wrap(function _callee2$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            _context3.next = 2;
            return (0, _process.take)(src);

          case 2:
            value = _context3.sent;

            if (!(value === _channels.CLOSED)) {
              _context3.next = 6;
              break;
            }

            if (!keepOpen) {
              dst.close();
            }
            return _context3.abrupt('break', 12);

          case 6:
            _context3.next = 8;
            return (0, _process.put)(dst, value);

          case 8:
            if (_context3.sent) {
              _context3.next = 10;
              break;
            }

            return _context3.abrupt('break', 12);

          case 10:
            _context3.next = 0;
            break;

          case 12:
          case 'end':
            return _context3.stop();
        }
      }
    }, _callee2, this);
  }));
  return dst;
}

function split(p, ch, trueBufferOrN, falseBufferOrN) {
  var tch = (0, _csp.chan)(trueBufferOrN);
  var fch = (0, _csp.chan)(falseBufferOrN);
  (0, _csp.go)(_regenerator2.default.mark(function _callee3() {
    var value;
    return _regenerator2.default.wrap(function _callee3$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            _context4.next = 2;
            return (0, _process.take)(ch);

          case 2:
            value = _context4.sent;

            if (!(value === _channels.CLOSED)) {
              _context4.next = 7;
              break;
            }

            tch.close();
            fch.close();
            return _context4.abrupt('break', 11);

          case 7:
            _context4.next = 9;
            return (0, _process.put)(p(value) ? tch : fch, value);

          case 9:
            _context4.next = 0;
            break;

          case 11:
          case 'end':
            return _context4.stop();
        }
      }
    }, _callee3, this);
  }));
  return [tch, fch];
}

function reduce(f, init, ch) {
  return (0, _csp.go)(_regenerator2.default.mark(function _callee4() {
    var result, value;
    return _regenerator2.default.wrap(function _callee4$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            result = init;

          case 1:
            _context5.next = 3;
            return (0, _process.take)(ch);

          case 3:
            value = _context5.sent;

            if (!(value === _channels.CLOSED)) {
              _context5.next = 6;
              break;
            }

            return _context5.abrupt('return', result);

          case 6:

            result = f(result, value);

          case 7:
            _context5.next = 1;
            break;

          case 9:
          case 'end':
            return _context5.stop();
        }
      }
    }, _callee4, this);
  }), [], true);
}

function onto(ch, coll, keepOpen) {
  return (0, _csp.go)(_regenerator2.default.mark(function _callee5() {
    var length, i;
    return _regenerator2.default.wrap(function _callee5$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            length = coll.length;
            // FIX: Should be a generic looping interface (for...in?)

            i = 0;

          case 2:
            if (!(i < length)) {
              _context6.next = 8;
              break;
            }

            _context6.next = 5;
            return (0, _process.put)(ch, coll[i]);

          case 5:
            i += 1;
            _context6.next = 2;
            break;

          case 8:
            if (!keepOpen) {
              ch.close();
            }

          case 9:
          case 'end':
            return _context6.stop();
        }
      }
    }, _callee5, this);
  }));
}

// TODO: Bounded?
function fromColl(coll) {
  var ch = (0, _csp.chan)(coll.length);
  onto(ch, coll);
  return ch;
}

function map(f, chs, bufferOrN) {
  var out = (0, _csp.chan)(bufferOrN);
  var length = chs.length;
  // Array holding 1 round of values
  var values = new Array(length);
  // TODO: Not sure why we need a size-1 buffer here
  var dchan = (0, _csp.chan)(1);
  // How many more items this round
  var dcount = void 0;
  // put callbacks for each channel
  var dcallbacks = new Array(length);
  var callback = function callback(i) {
    return function (value) {
      values[i] = value;
      dcount -= 1;
      if (dcount === 0) {
        (0, _process.putThenCallback)(dchan, values.slice(0));
      }
    };
  };

  for (var i = 0; i < length; i += 1) {
    dcallbacks[i] = callback(i);
  }

  (0, _csp.go)(_regenerator2.default.mark(function _callee6() {
    var _i, _values, _i2;

    return _regenerator2.default.wrap(function _callee6$(_context7) {
      while (1) {
        switch (_context7.prev = _context7.next) {
          case 0:
            dcount = length;
            // We could just launch n goroutines here, but for effciency we
            // don't
            for (_i = 0; _i < length; _i += 1) {
              try {
                (0, _process.takeThenCallback)(chs[_i], dcallbacks[_i]);
              } catch (e) {
                // FIX: Hmm why catching here?
                dcount -= 1;
              }
            }

            _context7.next = 4;
            return (0, _process.take)(dchan);

          case 4:
            _values = _context7.sent;
            _i2 = 0;

          case 6:
            if (!(_i2 < length)) {
              _context7.next = 13;
              break;
            }

            if (!(_values[_i2] === _channels.CLOSED)) {
              _context7.next = 10;
              break;
            }

            out.close();
            return _context7.abrupt('return');

          case 10:
            _i2 += 1;
            _context7.next = 6;
            break;

          case 13:
            _context7.next = 15;
            return (0, _process.put)(out, f.apply(undefined, (0, _toConsumableArray3.default)(_values)));

          case 15:
            _context7.next = 0;
            break;

          case 17:
          case 'end':
            return _context7.stop();
        }
      }
    }, _callee6, this);
  }));
  return out;
}

function merge(chs, bufferOrN) {
  var out = (0, _csp.chan)(bufferOrN);
  var actives = chs.slice(0);
  (0, _csp.go)(_regenerator2.default.mark(function _callee7() {
    var r, value, i;
    return _regenerator2.default.wrap(function _callee7$(_context8) {
      while (1) {
        switch (_context8.prev = _context8.next) {
          case 0:
            if (!(actives.length === 0)) {
              _context8.next = 2;
              break;
            }

            return _context8.abrupt('break', 15);

          case 2:
            _context8.next = 4;
            return (0, _process.alts)(actives);

          case 4:
            r = _context8.sent;
            value = r.value;

            if (!(value === _channels.CLOSED)) {
              _context8.next = 11;
              break;
            }

            // Remove closed channel
            i = actives.indexOf(r.channel);

            actives.splice(i, 1);
            _context8.next = 13;
            break;

          case 11:
            _context8.next = 13;
            return (0, _process.put)(out, value);

          case 13:
            _context8.next = 0;
            break;

          case 15:
            out.close();

          case 16:
          case 'end':
            return _context8.stop();
        }
      }
    }, _callee7, this);
  }));
  return out;
}

function into(coll, ch) {
  var result = coll.slice(0);
  return reduce(function (_result, item) {
    _result.push(item);
    return _result;
  }, result, ch);
}

function take(n, ch, bufferOrN) {
  var out = (0, _csp.chan)(bufferOrN);
  (0, _csp.go)(_regenerator2.default.mark(function _callee8() {
    var i, value;
    return _regenerator2.default.wrap(function _callee8$(_context9) {
      while (1) {
        switch (_context9.prev = _context9.next) {
          case 0:
            i = 0;

          case 1:
            if (!(i < n)) {
              _context9.next = 12;
              break;
            }

            _context9.next = 4;
            return (0, _process.take)(ch);

          case 4:
            value = _context9.sent;

            if (!(value === _channels.CLOSED)) {
              _context9.next = 7;
              break;
            }

            return _context9.abrupt('break', 12);

          case 7:
            _context9.next = 9;
            return (0, _process.put)(out, value);

          case 9:
            i += 1;
            _context9.next = 1;
            break;

          case 12:
            out.close();

          case 13:
          case 'end':
            return _context9.stop();
        }
      }
    }, _callee8, this);
  }));
  return out;
}

var NOTHING = {};

function unique(ch, bufferOrN) {
  var out = (0, _csp.chan)(bufferOrN);
  var last = NOTHING;
  (0, _csp.go)(_regenerator2.default.mark(function _callee9() {
    var value;
    return _regenerator2.default.wrap(function _callee9$(_context10) {
      while (1) {
        switch (_context10.prev = _context10.next) {
          case 0:
            _context10.next = 2;
            return (0, _process.take)(ch);

          case 2:
            value = _context10.sent;

            if (!(value === _channels.CLOSED)) {
              _context10.next = 5;
              break;
            }

            return _context10.abrupt('break', 11);

          case 5:
            if (!(value !== last)) {
              _context10.next = 9;
              break;
            }

            last = value;
            _context10.next = 9;
            return (0, _process.put)(out, value);

          case 9:
            _context10.next = 0;
            break;

          case 11:
            out.close();

          case 12:
          case 'end':
            return _context10.stop();
        }
      }
    }, _callee9, this);
  }));
  return out;
}

function partitionBy(f, ch, bufferOrN) {
  var out = (0, _csp.chan)(bufferOrN);
  var part = [];
  var last = NOTHING;
  (0, _csp.go)(_regenerator2.default.mark(function _callee10() {
    var value, newItem;
    return _regenerator2.default.wrap(function _callee10$(_context11) {
      while (1) {
        switch (_context11.prev = _context11.next) {
          case 0:
            _context11.next = 2;
            return (0, _process.take)(ch);

          case 2:
            value = _context11.sent;

            if (!(value === _channels.CLOSED)) {
              _context11.next = 11;
              break;
            }

            if (!(part.length > 0)) {
              _context11.next = 7;
              break;
            }

            _context11.next = 7;
            return (0, _process.put)(out, part);

          case 7:
            out.close();
            return _context11.abrupt('break', 22);

          case 11:
            newItem = f(value);

            if (!(newItem === last || last === NOTHING)) {
              _context11.next = 16;
              break;
            }

            part.push(value);
            _context11.next = 19;
            break;

          case 16:
            _context11.next = 18;
            return (0, _process.put)(out, part);

          case 18:
            part = [value];

          case 19:
            last = newItem;

          case 20:
            _context11.next = 0;
            break;

          case 22:
          case 'end':
            return _context11.stop();
        }
      }
    }, _callee10, this);
  }));
  return out;
}

function partition(n, ch, bufferOrN) {
  var out = (0, _csp.chan)(bufferOrN);
  (0, _csp.go)(_regenerator2.default.mark(function _callee11() {
    var part, i, value;
    return _regenerator2.default.wrap(function _callee11$(_context12) {
      while (1) {
        switch (_context12.prev = _context12.next) {
          case 0:
            part = new Array(n);
            i = 0;

          case 2:
            if (!(i < n)) {
              _context12.next = 16;
              break;
            }

            _context12.next = 5;
            return (0, _process.take)(ch);

          case 5:
            value = _context12.sent;

            if (!(value === _channels.CLOSED)) {
              _context12.next = 12;
              break;
            }

            if (!(i > 0)) {
              _context12.next = 10;
              break;
            }

            _context12.next = 10;
            return (0, _process.put)(out, part.slice(0, i));

          case 10:
            out.close();
            return _context12.abrupt('return');

          case 12:
            part[i] = value;

          case 13:
            i += 1;
            _context12.next = 2;
            break;

          case 16:
            _context12.next = 18;
            return (0, _process.put)(out, part);

          case 18:
            _context12.next = 0;
            break;

          case 20:
          case 'end':
            return _context12.stop();
        }
      }
    }, _callee11, this);
  }));
  return out;
}

// For channel identification
var genId = function () {
  var i = 0;

  return function () {
    i += 1;
    return '' + i;
  };
}();

var ID_ATTR = '__csp_channel_id';

function chanId(ch) {
  var id = ch[ID_ATTR];

  if (id === undefined) {
    id = ch[ID_ATTR] = genId();
  }
  return id;
}

var Tap = function Tap(channel, keepOpen) {
  (0, _classCallCheck3.default)(this, Tap);

  this.channel = channel;
  this.keepOpen = keepOpen;
};

var Mult = function () {
  function Mult(ch) {
    (0, _classCallCheck3.default)(this, Mult);

    this.taps = {};
    this.ch = ch;
  }

  (0, _createClass3.default)(Mult, [{
    key: 'muxch',
    value: function muxch() {
      return this.ch;
    }
  }, {
    key: 'tap',
    value: function tap(ch, keepOpen) {
      this.taps[chanId(ch)] = new Tap(ch, keepOpen);
    }
  }, {
    key: 'untap',
    value: function untap(ch) {
      delete this.taps[chanId(ch)];
    }
  }, {
    key: 'untapAll',
    value: function untapAll() {
      this.taps = {};
    }
  }]);
  return Mult;
}();

function mult(ch) {
  var m = new Mult(ch);
  var dchan = (0, _csp.chan)(1);
  var dcount = void 0;

  function makeDoneCallback(tap) {
    return function (stillOpen) {
      dcount -= 1;
      if (dcount === 0) {
        (0, _process.putThenCallback)(dchan, true);
      }
      if (!stillOpen) {
        m.untap(tap.channel);
      }
    };
  }

  (0, _csp.go)(_regenerator2.default.mark(function _callee12() {
    var _this = this;

    var _loop, _ret;

    return _regenerator2.default.wrap(function _callee12$(_context14) {
      while (1) {
        switch (_context14.prev = _context14.next) {
          case 0:
            _loop = _regenerator2.default.mark(function _loop() {
              var value, taps, t, initDcount;
              return _regenerator2.default.wrap(function _loop$(_context13) {
                while (1) {
                  switch (_context13.prev = _context13.next) {
                    case 0:
                      _context13.next = 2;
                      return (0, _process.take)(ch);

                    case 2:
                      value = _context13.sent;
                      taps = m.taps;
                      t = void 0;

                      if (!(value === _channels.CLOSED)) {
                        _context13.next = 9;
                        break;
                      }

                      (0, _keys2.default)(taps).forEach(function (id) {
                        t = taps[id];
                        if (!t.keepOpen) {
                          t.channel.close();
                        }
                      });

                      // TODO: Is this necessary?
                      m.untapAll();
                      return _context13.abrupt('return', 'break');

                    case 9:
                      dcount = (0, _keys2.default)(taps).length;
                      // XXX: This is because putAsync can actually call back
                      // immediately. Fix that
                      initDcount = dcount;
                      // Put value on tapping channels...

                      (0, _keys2.default)(taps).forEach(function (id) {
                        t = taps[id];
                        (0, _process.putThenCallback)(t.channel, value, makeDoneCallback(t));
                      });
                      // ... waiting for all puts to complete

                      if (!(initDcount > 0)) {
                        _context13.next = 15;
                        break;
                      }

                      _context13.next = 15;
                      return (0, _process.take)(dchan);

                    case 15:
                    case 'end':
                      return _context13.stop();
                  }
                }
              }, _loop, _this);
            });

          case 1:
            return _context14.delegateYield(_loop(), 't0', 2);

          case 2:
            _ret = _context14.t0;

            if (!(_ret === 'break')) {
              _context14.next = 5;
              break;
            }

            return _context14.abrupt('break', 7);

          case 5:
            _context14.next = 1;
            break;

          case 7:
          case 'end':
            return _context14.stop();
        }
      }
    }, _callee12, this);
  }));
  return m;
}

mult.tap = function (m, ch, keepOpen) {
  m.tap(ch, keepOpen);
  return ch;
};

mult.untap = function (m, ch) {
  m.untap(ch);
};

mult.untapAll = function (m) {
  m.untapAll();
};

var MIX_MUTE = 'mute';
var MIX_PAUSE = 'pause';
var MIX_SOLO = 'solo';
var VALID_SOLO_MODES = [MIX_MUTE, MIX_PAUSE];

var Mix = function () {
  function Mix(ch) {
    (0, _classCallCheck3.default)(this, Mix);

    this.ch = ch;
    this.stateMap = {};
    this.change = (0, _csp.chan)();
    this.soloMode = MIX_MUTE;
  }

  (0, _createClass3.default)(Mix, [{
    key: '_changed',
    value: function _changed() {
      (0, _process.putThenCallback)(this.change, true);
    }
  }, {
    key: '_getAllState',
    value: function _getAllState() {
      var stateMap = this.stateMap;
      var solos = [];
      var mutes = [];
      var pauses = [];
      var reads = void 0;

      (0, _keys2.default)(stateMap).forEach(function (id) {
        var chanData = stateMap[id];
        var state = chanData.state;
        var channel = chanData.channel;
        if (state[MIX_SOLO]) {
          solos.push(channel);
        }
        // TODO
        if (state[MIX_MUTE]) {
          mutes.push(channel);
        }
        if (state[MIX_PAUSE]) {
          pauses.push(channel);
        }
      });

      var i = void 0;
      var n = void 0;
      if (this.soloMode === MIX_PAUSE && solos.length > 0) {
        n = solos.length;
        reads = new Array(n + 1);
        for (i = 0; i < n; i += 1) {
          reads[i] = solos[i];
        }
        reads[n] = this.change;
      } else {
        reads = [];
        (0, _keys2.default)(stateMap).forEach(function (id) {
          var chanData = stateMap[id];
          var channel = chanData.channel;
          if (pauses.indexOf(channel) < 0) {
            reads.push(channel);
          }
        });
        reads.push(this.change);
      }

      return { solos: solos, mutes: mutes, reads: reads };
    }
  }, {
    key: 'admix',
    value: function admix(ch) {
      this.stateMap[chanId(ch)] = {
        channel: ch,
        state: {}
      };
      this._changed();
    }
  }, {
    key: 'unmix',
    value: function unmix(ch) {
      delete this.stateMap[chanId(ch)];
      this._changed();
    }
  }, {
    key: 'unmixAll',
    value: function unmixAll() {
      this.stateMap = {};
      this._changed();
    }
  }, {
    key: 'toggle',
    value: function toggle(updateStateList) {
      var _this2 = this;

      // [[ch1, {}], [ch2, {solo: true}]];
      var length = updateStateList.length;

      var _loop2 = function _loop2(i) {
        var ch = updateStateList[i][0];
        var id = chanId(ch);
        var updateState = updateStateList[i][1];
        var chanData = _this2.stateMap[id];

        if (!chanData) {
          chanData = _this2.stateMap[id] = {
            channel: ch,
            state: {}
          };
        }
        (0, _keys2.default)(updateState).forEach(function (mode) {
          chanData.state[mode] = updateState[mode];
        });
      };

      for (var i = 0; i < length; i += 1) {
        _loop2(i);
      }
      this._changed();
    }
  }, {
    key: 'setSoloMode',
    value: function setSoloMode(mode) {
      if (VALID_SOLO_MODES.indexOf(mode) < 0) {
        throw new Error('Mode must be one of: ', VALID_SOLO_MODES.join(', '));
      }
      this.soloMode = mode;
      this._changed();
    }
  }]);
  return Mix;
}();

function mix(out) {
  var m = new Mix(out);
  (0, _csp.go)(_regenerator2.default.mark(function _callee13() {
    var state, result, _value, channel, solos, stillOpen;

    return _regenerator2.default.wrap(function _callee13$(_context15) {
      while (1) {
        switch (_context15.prev = _context15.next) {
          case 0:
            state = m._getAllState();

          case 1:
            _context15.next = 3;
            return (0, _process.alts)(state.reads);

          case 3:
            result = _context15.sent;
            _value = result.value;
            channel = result.channel;

            if (!(_value === _channels.CLOSED)) {
              _context15.next = 11;
              break;
            }

            delete m.stateMap[chanId(channel)];
            state = m._getAllState();
            _context15.next = 22;
            break;

          case 11:
            if (!(channel === m.change)) {
              _context15.next = 15;
              break;
            }

            state = m._getAllState();
            _context15.next = 22;
            break;

          case 15:
            solos = state.solos;

            if (!(solos.indexOf(channel) > -1 || solos.length === 0 && !(state.mutes.indexOf(channel) > -1))) {
              _context15.next = 22;
              break;
            }

            _context15.next = 19;
            return (0, _process.put)(out, _value);

          case 19:
            stillOpen = _context15.sent;

            if (stillOpen) {
              _context15.next = 22;
              break;
            }

            return _context15.abrupt('break', 24);

          case 22:
            _context15.next = 1;
            break;

          case 24:
          case 'end':
            return _context15.stop();
        }
      }
    }, _callee13, this);
  }));
  return m;
}

mix.add = function admix(m, ch) {
  m.admix(ch);
};

mix.remove = function unmix(m, ch) {
  m.unmix(ch);
};

mix.removeAll = function unmixAll(m) {
  m.unmixAll();
};

mix.toggle = function toggle(m, updateStateList) {
  m.toggle(updateStateList);
};

mix.setSoloMode = function setSoloMode(m, mode) {
  m.setSoloMode(mode);
};

function constantlyNull() {
  return null;
}

var Pub = function () {
  function Pub(ch, topicFn, bufferFn) {
    (0, _classCallCheck3.default)(this, Pub);

    this.ch = ch;
    this.topicFn = topicFn;
    this.bufferFn = bufferFn;
    this.mults = {};
  }

  (0, _createClass3.default)(Pub, [{
    key: '_ensureMult',
    value: function _ensureMult(topic) {
      var m = this.mults[topic];
      var bufferFn = this.bufferFn;
      if (!m) {
        m = this.mults[topic] = mult((0, _csp.chan)(bufferFn(topic)));
      }
      return m;
    }
  }, {
    key: 'sub',
    value: function sub(topic, ch, keepOpen) {
      var m = this._ensureMult(topic);
      return mult.tap(m, ch, keepOpen);
    }
  }, {
    key: 'unsub',
    value: function unsub(topic, ch) {
      var m = this.mults[topic];
      if (m) {
        mult.untap(m, ch);
      }
    }
  }, {
    key: 'unsubAll',
    value: function unsubAll(topic) {
      if (topic === undefined) {
        this.mults = {};
      } else {
        delete this.mults[topic];
      }
    }
  }]);
  return Pub;
}();

function pub(ch, topicFn) {
  var bufferFn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : constantlyNull;

  var p = new Pub(ch, topicFn, bufferFn);
  (0, _csp.go)(_regenerator2.default.mark(function _callee14() {
    var _this3 = this;

    var _loop3, _ret3;

    return _regenerator2.default.wrap(function _callee14$(_context17) {
      while (1) {
        switch (_context17.prev = _context17.next) {
          case 0:
            _loop3 = _regenerator2.default.mark(function _loop3() {
              var value, mults, topic, m, stillOpen;
              return _regenerator2.default.wrap(function _loop3$(_context16) {
                while (1) {
                  switch (_context16.prev = _context16.next) {
                    case 0:
                      _context16.next = 2;
                      return (0, _process.take)(ch);

                    case 2:
                      value = _context16.sent;
                      mults = p.mults;

                      if (!(value === _channels.CLOSED)) {
                        _context16.next = 7;
                        break;
                      }

                      (0, _keys2.default)(mults).forEach(function (topic) {
                        mults[topic].muxch().close();
                      });
                      return _context16.abrupt('return', 'break');

                    case 7:
                      // TODO: Somehow ensure/document that this must return a string
                      // (otherwise use proper (hash)maps)
                      topic = topicFn(value);
                      m = mults[topic];

                      if (!m) {
                        _context16.next = 14;
                        break;
                      }

                      _context16.next = 12;
                      return (0, _process.put)(m.muxch(), value);

                    case 12:
                      stillOpen = _context16.sent;

                      if (!stillOpen) {
                        delete mults[topic];
                      }

                    case 14:
                    case 'end':
                      return _context16.stop();
                  }
                }
              }, _loop3, _this3);
            });

          case 1:
            return _context17.delegateYield(_loop3(), 't0', 2);

          case 2:
            _ret3 = _context17.t0;

            if (!(_ret3 === 'break')) {
              _context17.next = 5;
              break;
            }

            return _context17.abrupt('break', 7);

          case 5:
            _context17.next = 1;
            break;

          case 7:
          case 'end':
            return _context17.stop();
        }
      }
    }, _callee14, this);
  }));
  return p;
}

pub.sub = function (p, topic, ch, keepOpen) {
  return p.sub(topic, ch, keepOpen);
};

pub.unsub = function (p, topic, ch) {
  p.unsub(topic, ch);
};

pub.unsubAll = function (p, topic) {
  p.unsubAll(topic);
};

function pipelineInternal(n, to, from, close, taskFn) {
  if (n <= 0) {
    throw new Error('n must be positive');
  }

  var jobs = (0, _csp.chan)(n);
  var results = (0, _csp.chan)(n);

  (0, _times2.default)(n, function () {
    (0, _csp.go)(_regenerator2.default.mark(function _callee15(_taskFn, _jobs, _results) {
      var job;
      return _regenerator2.default.wrap(function _callee15$(_context18) {
        while (1) {
          switch (_context18.prev = _context18.next) {
            case 0:
              _context18.next = 2;
              return (0, _process.take)(_jobs);

            case 2:
              job = _context18.sent;

              if (_taskFn(job)) {
                _context18.next = 6;
                break;
              }

              _results.close();
              return _context18.abrupt('break', 8);

            case 6:
              _context18.next = 0;
              break;

            case 8:
            case 'end':
              return _context18.stop();
          }
        }
      }, _callee15, this);
    }), [taskFn, jobs, results]);
  });

  (0, _csp.go)(_regenerator2.default.mark(function _callee16(_jobs, _from, _results) {
    var v, p;
    return _regenerator2.default.wrap(function _callee16$(_context19) {
      while (1) {
        switch (_context19.prev = _context19.next) {
          case 0:
            _context19.next = 2;
            return (0, _process.take)(_from);

          case 2:
            v = _context19.sent;

            if (!(v === _channels.CLOSED)) {
              _context19.next = 6;
              break;
            }

            _jobs.close();
            return _context19.abrupt('break', 13);

          case 6:
            p = (0, _csp.chan)(1);
            _context19.next = 9;
            return (0, _process.put)(_jobs, [v, p]);

          case 9:
            _context19.next = 11;
            return (0, _process.put)(_results, p);

          case 11:
            _context19.next = 0;
            break;

          case 13:
          case 'end':
            return _context19.stop();
        }
      }
    }, _callee16, this);
  }), [jobs, from, results]);

  (0, _csp.go)(_regenerator2.default.mark(function _callee17(_results, _close, _to) {
    var p, res, v;
    return _regenerator2.default.wrap(function _callee17$(_context20) {
      while (1) {
        switch (_context20.prev = _context20.next) {
          case 0:
            _context20.next = 2;
            return (0, _process.take)(_results);

          case 2:
            p = _context20.sent;

            if (!(p === _channels.CLOSED)) {
              _context20.next = 6;
              break;
            }

            if (_close) {
              _to.close();
            }
            return _context20.abrupt('break', 20);

          case 6:
            _context20.next = 8;
            return (0, _process.take)(p);

          case 8:
            res = _context20.sent;

          case 9:
            _context20.next = 11;
            return (0, _process.take)(res);

          case 11:
            v = _context20.sent;

            if (!(v === _channels.CLOSED)) {
              _context20.next = 14;
              break;
            }

            return _context20.abrupt('break', 18);

          case 14:
            _context20.next = 16;
            return (0, _process.put)(_to, v);

          case 16:
            _context20.next = 9;
            break;

          case 18:
            _context20.next = 0;
            break;

          case 20:
          case 'end':
            return _context20.stop();
        }
      }
    }, _callee17, this);
  }), [results, close, to]);

  return to;
}

function pipeline(to, xf, from, keepOpen, exHandler) {
  function taskFn(job) {
    if (job === _channels.CLOSED) {
      return null;
    }

    var _job = (0, _slicedToArray3.default)(job, 2),
        v = _job[0],
        p = _job[1];

    var res = (0, _csp.chan)(1, xf, exHandler);

    (0, _csp.go)(_regenerator2.default.mark(function _callee18(ch, value) {
      return _regenerator2.default.wrap(function _callee18$(_context21) {
        while (1) {
          switch (_context21.prev = _context21.next) {
            case 0:
              _context21.next = 2;
              return (0, _process.put)(ch, value);

            case 2:
              res.close();

            case 3:
            case 'end':
              return _context21.stop();
          }
        }
      }, _callee18, this);
    }), [res, v]);

    (0, _process.putThenCallback)(p, res);

    return true;
  }

  return pipelineInternal(1, to, from, !keepOpen, taskFn);
}

function pipelineAsync(n, to, af, from, keepOpen) {
  function taskFn(job) {
    if (job === _channels.CLOSED) {
      return null;
    }

    var _job2 = (0, _slicedToArray3.default)(job, 2),
        v = _job2[0],
        p = _job2[1];

    var res = (0, _csp.chan)(1);
    af(v, res);
    (0, _process.putThenCallback)(p, res);

    return true;
  }

  return pipelineInternal(n, to, from, !keepOpen, taskFn);
}
// Possible "fluid" interfaces:

// thread(
//   [fromColl, [1, 2, 3, 4]],
//   [mapFrom, inc],
//   [into, []]
// )

// thread(
//   [fromColl, [1, 2, 3, 4]],
//   [mapFrom, inc, _],
//   [into, [], _]
// )

// wrap()
//   .fromColl([1, 2, 3, 4])
//   .mapFrom(inc)
//   .into([])
//   .unwrap();